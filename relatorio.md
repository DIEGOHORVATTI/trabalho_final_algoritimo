* Tentei usar o padrão de projeto MVC mesmo o programa não sendo orientado a objeto, com a lógica de padrão de projeto destinado a cada pasta ("build", "src", "view", "docs", "controller", "bin", "API", "model") também consumi uma API para leitura de arquivos de configuração para ter um programa mais contextual as regras de software de mercado, também usei um arquivo make.sh ("-rwxr-xr-x"), um arquivo executável visando a semelhança com um arquivo makefile porem com muitas diferenças, pois invés de também verificar versões ou pacotes, ou conflitos este makefile tem a finalidade de ler flags de teclado ("./make.sh --h"), ao dar um "-h" help o programa printa no terminal uma série de flags que se pode usar e entre elas existe a flag "--start" que compila e executa o programa entre outras bem legais... sobre a regra de variáveis globais eu dei uma pequena burladinha no sistema, pois na pasta publica ("src") existe um arquivo chamado "colors.h" que basicamente define um grupo de string com começo e fim para depuração de cores para ajudar no front-end de linha de comando exemplo de uso: ("printf("\n\n [[ %sSimio%s ]]", __COLOR_LIGHT_PURPLE, __COLOR_FIM) "), também na pasta publica existe um arquivo chamado "header.h" que tema finalidade de incluir todas as libs e arquivos na hora da compilação seguindo a ordem síncrona("de cima para baixo"), desta forma eu pude compilar um arquivo e ter as funções e procedimentos publicas para outros arquivos já que eu não setei as funções e procedimentos como "plublic" ou "privated"... a compilação foi feita na pasta ("build") onde contem o arquivo "main.c" que inclui e compila um binário na pasta ("bin") em primeiro lugar os header que contem as libs importadas, E depois disto também compila todos os arquivos do programa tendo o mesmo efeito de compartilhamento de funções e procedimentos que o "header.h" no mesmo arquivo contem a função "main()" que chama o procedimento de preencher a matriz e o de visualização geral da pasta "view".
  * Bom agora na parte mais lógica do programa basicamente eu pensei que deveria ler as ocorrências em todas as linhas da matriz independente se fosse vertical, horizontal ou uma diagonal principal, ou segundaria logo na pasta onde contem o back-end do programa "controller" o arquivo "read_file.c" tem a função lerFile() que retorna 1 ou 0 consumido pelo front end posteriormente assim ele lê o arquivo de texto e o atribui a um ponteiro de vetor dinâmico de string, que depois é passado por parâmetro para a função "isSimian(char *dna)" após isso a string é atribuída a um ponteiro de ponteiros dinâmicos(matriz) e o meu cheque-mate para responder à questão em si, é desmembrar a matriz em string´s e percorrê-las verificando se existe uma sub string com a função "strstr(stringPercorrido, ocorrencia)" se sim, retorna 1, seguida desta lógica eu verifico os vetores horizontais e caso ainda retorne 0  vai para a verificação vertical depois as diagonais principais e por último as diagonais segundarias. Fiz desta forma, pois justamente aparenta poupa processador e verificando as horizontais e depois verticais tem bem menos algébrica de ponteiros, está foi minha lógica para resolver o algoritmo.
  * Sobre o consumo da API da leitura do arquivo.ini tive que ler muito para fazê-la funcioná-la não seria sarcasmo falar que ela deu mais trabalho que o trabalho em si. Bom primeiramente tive que criar o arquivo "verified_file_config.c" para verificar a integridade dos dados do arquivo e se ele é existente ou não depois tive que criar o arquivo "verified_structure.c" para verificar se a categoria de dado estava preenchida e alterar a categoria de dado já que na leitura do config.ini vem tudo como carácter sem tipo então usei a função "atoi()" para converter em números inteiros e "strdup()" para string .
   * Algo muito importante no trabalho é  a função do tipo de dado struct contido no "model" com ele foi bem legal ficar alterando os dados ao decorrer do programa. Outra coisa interessante é a possibilidade de o programa criar matrizes dinâmicas e randômicas caso for especificado no arquivo de configuração "ALEATORIO" como 'true'.